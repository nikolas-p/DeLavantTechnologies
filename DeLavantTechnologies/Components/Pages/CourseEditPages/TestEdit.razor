@inject ITestService TestService
@inject IQuestionService QuestionService
@using DeLavantTechnologies.Components.Pages.QuestionEditPages
@using MongoDB.Bson
@using DeLavant.Domain.Tests
@rendermode InteractiveServer
@if (Test != null)
{
    <div class="item-content">
        <EditForm Model="@Test" OnValidSubmit="SaveTest" FormName="@formName">
            <DataAnnotationsValidator />
            <ValidationSummary />

            <!-- HEADER -->
            <div class="item-content-header">
                <div class="item-content-header-left">
                    <button class="circle-button primary-red x-circle-fill-icon" type="button" @onclick="DeleteTest"></button>
                </div>
                <div class="item-content-header-center">
                    <h5>Редактирование теста</h5>
                </div>
                <div class="item-content-header-right">
                    <button class="circle-button primary-purple check-circle-fill-icon" type="submit"></button>
                </div>
            </div>

            <!-- MAIN -->
            <div class="item-content-main">
                <InputText class="form-control mb-2" @bind-Value="Test.Title" placeholder="Название теста" />
                <InputTextArea class="form-control mb-3" @bind-Value="Test.Description" placeholder="Описание теста" />

                @if (Questions.Any())
                {
                    <h5>Вопросы теста</h5>
                    <div class="column">
                        @foreach (var q in Questions)
                        {
                            //Console.WriteLine($"Question {q.Id} type={q.Type}");
                            <div @key="q.Id">
                                <DynamicComponent Type="Resolve(q.Type)" Parameters="@(new Dictionary<string, object?>
                                {
                                    ["Question"] = q,
                                    ["OnQuestionUpdated"] = EventCallback.Factory.Create<Question>(this, OnQuestionUpdated),
                                    ["OnQuestionDeleted"] = EventCallback.Factory.Create<string>(this, OnQuestionDeletedAsync)
                                })" />
                            </div>
                        }
                    </div>
                }
            </div>

            <!-- FOOTER -->
            <div class="item-content-footer">
                <div class="item-content-footer-center">
                    <div class="row-container">
                        <button class="square-button primary-gray list-ul-icon" type="button" @onclick="AddOne"></button>
                        <button class="square-button primary-gray list-check-icon" type="button" @onclick="AddMany"></button>
                        <button class="square-button primary-gray list-ol-icon" type="button" @onclick="AddStep"></button>
                        <button class="square-button primary-gray chat-square-text-icon" type="button" @onclick="AddNote"></button>
                       
                    </div>
                </div>
            </div>
        </EditForm>
    </div>
}
else
{
    <h4>загрузка теста</h4>
}
@code {
    [Parameter] public string TestId { get; set; }
    [Parameter] public EventCallback<string> OnDeleted { get; set; }

    private Test Test { get; set; }
    private List<Question> Questions { get; set; } = new();
    private string formName => $"TestForm_{Test?.Id}";

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(TestId))
        {
            Test = await TestService.GetTestByIdAsync(TestId);
            if (Test != null)
            {
                Questions = await QuestionService.GetQuestionsByIdsAsync(Test.Questions ?? new List<string>());
            }
        }
    }

   private Type Resolve(string type)
{
    if (string.IsNullOrWhiteSpace(type))
        return typeof(QuestionNoteEdit);

    switch (type.ToLowerInvariant())
    {
        case "one":
            return typeof(QuestionOneEdit);
        case "many":
            return typeof(QuestionManyEdit);
        case "note":
            return typeof(QuestionNoteEdit);
        case "step":
            return typeof(QuestionStepEdit);
        default:
            return typeof(QuestionNoteEdit);
    }
}


    private async Task SaveTest()
    {
        Test.Questions = Questions.Select(q => q.Id).ToList();
        foreach (var q in Questions)
            await QuestionService.SaveQuestionAsync(q);

        await TestService.SaveTestAsync(Test);
    }

    private async Task DeleteTest()
    {
        foreach (var qId in Test.Questions ?? new List<string>())
            await QuestionService.DeleteQuestionAsync(qId);

        await TestService.DeleteTestAsync(Test.Id);
        await OnDeleted.InvokeAsync(Test.Id);
    }
    private void AddOne() => AddQuestion("one");
    private void AddMany() => AddQuestion("many");
    private void AddNote() => AddQuestion("note");
    private void AddStep() => AddQuestion("step");


    private async Task AddQuestion(string type)
    {
        var q = new Question
            {
                Id = ObjectId.GenerateNewId().ToString(),
                Type = type.ToLowerInvariant(),
                Answers = new List<Answer>()
            };

        Questions.Add(q);
        Test.Questions ??= new List<string>();
        Test.Questions.Add(q.Id);

        // Сразу сохраняем вопрос в базе
        await QuestionService.SaveQuestionAsync(q);

        // Обновляем тест в базе
        await TestService.SaveTestAsync(Test);

        StateHasChanged(); // обновляем UI сразу
    }

    private void OnQuestionUpdated(Question q)
    {
        var idx = Questions.FindIndex(x => x.Id == q.Id);
        if (idx >= 0)
            Questions[idx] = q;

        StateHasChanged(); // чтобы UI обновился сразу
    }

    private async Task OnQuestionDeletedAsync(string id)
    {
        var q = Questions.FirstOrDefault(x => x.Id == id);
        if (q != null)
        {
            Questions.Remove(q);
            Test.Questions?.Remove(id);

            // Сохраняем изменения в тесте сразу
            await TestService.SaveTestAsync(Test);

            StateHasChanged();
        }
    }

}